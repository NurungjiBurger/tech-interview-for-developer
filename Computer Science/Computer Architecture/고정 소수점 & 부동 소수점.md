## 고정 소수점 & 부동 소수점

<br>

컴퓨터에서 실수를 표현하는 방법은 `고정 소수점`과 `부동 소수점` 두가지 방식이 존재한다.

<br>

1. #### 고정 소수점(Fixed Point)

   > 소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 (정수 + 소수)
   >
   > ```
   > -3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함
   > ```

   ![고정 소수점 방식](http://tcpschool.com/lectures/img_c_fixed_point.png)

    예를 들어, 7.625라는 실수가 있다면 이는 2진수 변환시 111.101이 된다.
    16비트 체계라고 한다면 다음과 같이 표현된다.
    `0 0 0 0 0 1 1 1 . 1 0 1 0 0 0 0`
    맨 앞 한자리는 부호 비트(Sign Bit)로 0이면 양수, 1이면 음수이다.
    나머지 비트들은 소수점을 기준으로 정수부랑 소수부로 표현하는데 소수점의 위치는 미리 정해둔다.

   **장점** : 실수를 정수부와 소수부로 표현하여 구현이 매우 단순하다.

   **단점** : 표현할 수 있는 수의 범위가 적어서 정밀도가 낮기 때문에 범용 시스템에서는 거의 쓰이지 않는다. 그만큼 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)

   <br>

   <br>

2. #### 부동 소수점(Floating Point)

   > 실수를 가수부 + 지수부로 표현한다.
   >
   > - 가수 : 실수의 실제값 표현
   > - 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄

   **지수의 값에 따라 소수점이 움직이는 방식**을 활용한 실수 표현 방법이다.

   즉, 소수점의 위치가 고정되어 있지 않는다.

   ![32비트 부동 소수점](http://tcpschool.com/lectures/img_c_floating_point_32.png)

    이는 과학적 표기법을 컴퓨터의 2진수로 바꾸는 방식인데 예를들어, 빛의 속도는 300,000,000m/s 이지만 과학적인 표현으로는 3.0 * 10^8m/s 로 표현한다. 즉 여기서 3.0이 가수부이고 8이 지수부에 해당한다.

    먼저 표준 양식의 정규화의 과정을 거쳐야한다. 정규화는 정수부에 1만 남을때까지 소수점을 왼쪽이나 오른쪽으로 이동시키면 된다. 위와 같은 예시로 7.625는 111.101 이므로 오른쪽으로 두 칸 이동시켜 정규화하면 1.11101 & 2^2가 된다.
    그 다음, 부호 비트는 고정 소수점과 동일하게 사용하고 23자리의 가수부는 정규화 결과 오른쪽에 있는 숫자들을 채워넣으면 된다. 8자리 지수부에는 2^n에 해당하는 수 2를 2진수로 바꾼 '10'을 넣으면 되는데 문제는 그대로 넣는게 아니라 bias라는 지정된 수를 더한 다음 넣어야한다.
    IEEE 표준에서 32비트의 bias는 127이므로 129를 2진수로 바꾼 10000001이 들어가서 최종적으로 `0 1 0 0 0 0 0 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0`이 된다.

    지수가 음수가 될 수도 있기 때문에 bias를 활용하며 0 ~ 127 구간은 음수를 128 ~ 255 구간은 양수를 표현하도록 만든 것이다. 64비트 체계에서는 지수부가 11비트, 가수부가 52비트이다. 지수부가 2048개의 수를 표현할 수 있으므로 0 ~ 1023 구간은 음수, 1024 ~ 2047 구간은 양수를 의미하며 bias는 1023이 된다. 이렇게하면 양수냐 음수냐 표기가 필요없이 bias(편향)를 통해 **항상 양수**로 만들어서 저장할 수 있게된다.

   **장점** : 표현할 수 있는 수의 범위가 넓어지며 정밀한 표현이 가능하기 때문에 현재 대부분 시스템에서 활용 중이다.

   **단점** : 한정된 비트로 무한한 실수를 표현하려는 시도이기 때문에 오차가 발생할 수 있다. (컴퓨터가 표현할 수 없는 숫자가 필연적으로 존재함)
   
   <br>

   <br>
   
3. #### 고정 소수점과 부동 소수점의 일반적인 사용 사례.

**고정 소수점 사용 상황.**
1. 임베디드 시스템과 마이크로컨트롤러
    - 메모리와 처리 능력이 제한된 환경에서 고정 소수점 연산이 일반적입니다. 이는 부동 소수점 연산을 지원하는 하드웨어가 없거나, 그러한 연산이 배터리 수명이나 다른 자원을 과도하게 소모할 수 있기 때문입니다.

2. 실시간 시스템
    - 예측 가능한 실행 시간이 중요한 실시간 응용 프로그램에서는 고정 소수점 연산이 선호됩니다. 이는 부동 소수점 연산이 가변적인 실행 시간을 가질 수 있기 때문입니다.

3. 비용 민감형 하드웨어
    - 부동 소수점 연산자를 지원하는 비용이 더 들 수 있어, 가격을 낮추기 위해 고정 소수점 연산을 사용하는 경우가 있습니다.

4. 디지털 신호 처리(DSP)
    - 일부 디지털 신호 처리 알고리즘은 정확하게 정의된 범위 내의 값을 사용하기 때문에 고정 소수점 연산으로 충분한 경우가 많습니다.

**부동 소수점 사용 상황.**
1. 과학적 계산
    - 넓은 범위의 값과 높은 정밀도가 요구되는 과학적 및 엔지니어링 계산에는 부동 소수점이 사용됩니다.

2. 3D 그래픽스
    - 3D 모델링과 같은 그래픽 작업에서는 부동 소수점 연산이 광범위하게 사용되며, 높은 정밀도와 다양한 크기의 값을 처리할 수 있어야 합니다.

3. 금융 분석
    - 복잡한 금융 모델링과 위험 평가에서는 높은 수준의 정밀도가 필요할 수 있으며, 부동 소수점 연산이 적합할 수 있습니다.

4. 컴퓨터 시뮬레이션
    - 물리적 시스템의 시뮬레이션은 넓은 범위의 값과 높은 정밀도를 요구하기 때문에, 부동 소수점 연산이 필수적입니다.

**결론.**
- 고정 소수점은 주로 리소스가 제한적이고 높은 정밀도가 필요하지 않은 환경에서 사용됩니다.
- 부동 소수점은 더 넓은 범위와 높은 정밀도를 필요로 하는 복잡한 계산에 적합합니다.
- 현대 프로세서의 경우, 부동 소수점 연산의 속도도 매우 빨라져서 예전만큼 고정 소수점과 부동 소수점 사이의 성능 차이가 크지 않을 수 있습니다.
