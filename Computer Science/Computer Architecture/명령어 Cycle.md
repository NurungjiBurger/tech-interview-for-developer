## 명령어 Cycle

- PC | 프로그램 카운터(Program Counter) : 다음 실행할 명령어의 주소를 저장
- MAR | 메모리 주소 레지스터(Memory Address Register) : 다음에 읽거나 쓸 기억장소의 주소를 지정
- MBR | 메모리 버퍼 레지스터(Memory Buffer Register) : 기억장치에 저장될 데이터 혹은 기억장치로부터 읽은 데이터를 임시 저장하는 곳으로 MDR(Memory Data Register)라고도 불림
- IR | 명령어 레지스터(Instruction Register) : 현재 실행 중인 명령어 저장
- ALU | 산술 논리 연산 장치(Arithmetic Logic Unit) : 산술연산과 논리연산 수행

<br>

#### Fetch Cycle(인출 사이클)

---

> 명령어를 주기억장치에서 CPU 명령어 레지스터로 가져와 해독하는 단계

1) PC → MAR: **프로그램 카운터(PC)**에 있는 값을 **메모리 주소 레지스터(MAR)**로 보낸다.

2) PC → PC + 1: PC 값을 1 증가시켜 다음 명령어를 미리 가리키게 한다.

3) Memory → MBR: MAR이 가리키는 메모리 주소의 명령어를 읽어와 **메모리 버퍼 레지스터(MBR)**에 저장한다.

4) MBR → IR: MBR의 내용을 **명령어 레지스터(IR)**로 옮긴다.

이후 제어 장치가 IR에 있는 명령어를 해독(Decode)한다. 이 결과에 따라 다음 행동이 결정된다.

1. 명령어가 간접 주소 방식이라면 Indirect Cycle(간접 사이클) 실행 후, Execute Cycle(실행 사이클)로 넘어간다.
2. 명령어가 직접 주소 방식이라면 바로 Execute Cycle(실행 사이클)로 넘어간다.
3. Execute Cycle을 통해 연산이나 데이터 이동이 완료된다.
4. 하나의 명령어 실행이 **완전히 끝난 후**, 다음 명령어를 인출하기 전 외부로부터 인터럽트 요청이 있었는지 확인하고 있었다면 Interupt Cycle(인터럽트 사이클)을 실행해 현재 상태를 저장하고 인터럽트 루틴으로 넘어간다.
5. 인터럽트가 없거나 인터럽트까지 모두 처리가 완료되었다면 다시 fetch Cycle(인출 사이클)로 돌아간다.

<br>

#### Execute Cycle(실행 사이클)

---

> 인출 사이클을 통해 가져온 명령어를 실제로 수행하는 단계

- 메모리 참조 (예: ADD addr)
    1. 명령어(IR)에 포함된 주소 부분을 MAR로 보냄
    2. MAR이 가리키는 메모리에서 데이터를 읽어 MBR에 저장
    3. MBR에 저장된 데이터와 누산기(AC) 등의 레지스터 값을 ALU로 보냄
    4. ALU에서 덧셈 연산을 수행하고, 결과를 다시 누산기(AC)에 저장

- 레지스터 참조 (예: ADD R1)
    1. ALU가 특정 레지스터(R1)의 값과 누산기(AC)의 값을 입력으로 받음
    2. ALU에서 덧셈 연산을 수행하고, 결과를 누산기(AC)에 저장

- 입출력 (I/O)
    1. 명령어에 포함된 입출력 모듈 주소를 지정
    2. 해당 입출력 모듈로 데이터 전송 명령을 보냄


<br>

#### Interupt Cycle(인터럽트 사이클)

---

> 현재 실행 중인 프로그램을 중단하고, 발생한 인터럽트를 처리하기 위한 준비를 하는 단계

1) 현재 PC에 저장된 값(복귀 주소)을 MBR로 옮김

2) 인터럽트 처리 루틴(ISR)이 정해놓은 스택 주소 등을 MAR로 보냄

3) MBR에 저장된 복귀 주소를 MAR이 가리키는 메모리(스택)에 저장

4) 인터럽트 서비스 루틴(ISR)의 시작 주소를 PC에 적재

<br>

#### Indirect Cycle(간접 사이클)

---

> 명령어에 포함된 주소를 이용해 데이터의 실제 주소(유효 주소)를 메모리에서 가져오는 단계

1) 명령어(IR)의 주소 부분을 MAR로 보냄

2) MAR이 가리키는 메모리 위치에서 실제 주소를 읽어 MBR에 저장

3) MBR에 저장된 실제 주소를 IR의 주소 부분에 갱신