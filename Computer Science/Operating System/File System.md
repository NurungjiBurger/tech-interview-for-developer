## 파일 시스템(File System)

<br>

컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법이다.

저장매체에는 수많은 파일이 있기 때문에, 이런 파일들을 관리하는 방법을 말한다.

##### <br>

##### 특징

- 커널 영역에서 동작
- 파일 CRUD 기능을 원활히 수행하기 위한 목적

- 계층적 디렉터리 구조를 가짐
- 디스크 파티션 별로 하나씩 둘 수 있음

##### 역할

- 파일 관리
- 보조 저장소 관리
- 파일 무결성 메커니즘
- 접근 방법 제공

##### 개발 목적

- 하드디스크와 메인 메모리 속도차를 줄이기 위함
- 파일 관리
- 하드디스크 용량 효율적 이용

##### 구조

- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 정보
  - 일반적으로 사용자가 보는 파일구조는 이 메타 영역 정보를 바탕으로 시각화 한 것.
- 데이터 영역 : 파일의 실제 데이터

<br>

<br>

#### 접근 방법

1. ##### 순차 접근(Sequential Access)

   > 가장 간단한 접근 방법으로, 대부분 연산은 read와 write
   책을 읽을 때 원하는 내용을 찾기 위해 1페이지부터 쭉 읽어나가는 것과 같은 방법.

   <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.1.png">

   현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행. 뒤로 돌아갈 땐 지정한 offset만큼 되감기를 해야 한다. (테이프 모델 기반)
   

2. ##### 직접 접근(Direct Access)

   > 특별한 순서없이, 빠르게 레코드를 read, write 가능
   책을 읽을 때 원하는 내용을 찾기 위해 바로 253페이지 같은 페이지로 접근하는 방법.

   <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.2.png">

   현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현이 가능하다.

   무작위 파일 블록에 대한 임의 접근을 허용한다. 따라서 순서의 제약이 없음

   대규모 정보를 접근할 때 유용하기 때문에 '데이터베이스'에 활용된다.

3. 기타 접근

   > 직접 접근 파일에 기반하여 색인 구축

   <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.3.png">

   크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법임

<br>

"1KB짜리 파일 1000개를 쓰는 것"과 "1MB짜리 파일 1개를 쓰는 것" 중 어떤 작업이 더 빠르고 효율적일까?
- 후자가 더 빠름.
- 관리적 오버헤드
  - 파일 생성 시, "메타 데이터"도 함께 만들어야하는데 여기에는 파일 생성시간, 종류, 크기, 이름 등을 기록한다.1개의 파일 생성과 1000개의 파일 생성은 이 메타 데이터 또한, '한 번 생성'과 '천 번 반복 생성'하는 차이라고 보면 된다.
- 물리적 접근비용
  - 특히, HDD상에서는 데이터를 쓰는 것보다 데이터를 쓸 공간을 찾기 위해 헤더를 움직이는 "탐색 시간"이 시간을 더 많이 쓰는 병목 구간임. 즉, 1개 파일 생성은 빈 공간을 한 번만 찾아가는 오버헤드를 가지지만 1000개 파일 생성은 빈 공간을 1000번 찾아가는 오버헤드가 발생한다. 때문에 대부분의 시간을 데이터 쓰기보다 비어있는 메모리 공간을 찾는 상황이 발생할 수 있다.

- 현대에 들어서는 SDD가 표준으로 사용되고 있는데 SDD 또한, 후자가 더 빠르다.
  - 맵핑 테이블 오버헤드
    - SDD 컨트롤러는 파일 시스템이 요청하는 논리적 주소와 실제 데이터가 저장된 물리적 페이지 주소를 연결하는 '맵핑 테이블'로 관리한다. 파일 쓰기 한 번당 이 맵핑 테이블을 한 번 조회하고 업데이트해야하기 때문에 1000개의 파일 생성 시 1000번의 조회와 업데이트가 이루어지기 때문에 오버헤드가 크다.
  - 내부 단편화와 쓰기 증폭
    - 1KB 파일은 최소 쓰기 단위인 4KB보다 작다. 따라서 3KB가 낭비된다. 그렇다면, 4KB로 맞추어서 저장하면 어떨까? 이 역시 나중에는 낭비가 된다.
    - 만약, 파일이 하나라도 삭제되면 블록내에 메모리 공간이 비게 되고 빈 공간을 효율적으로 활용하기 위해 "가비지 컬렉션"이 청소를 시작한다.이 과정에서 유효한 데이터들을 옮기고 기존 블럭 전체를 지워야하는데 실제 쓰려는 데이터보다 훨씬 많은 양의 쓰기 작업이 발생하게 된다. 이를 "쓰기 증폭"이라 부르며 SSD의 성능과 수명을 저하하는 주요 원인이다.


<br>

### 디렉터리와 디스크 구조

---

- ##### 1단계 디렉터리

  > 가장 간단한 구조

  파일들은 서로 유일한 이름을 가짐. 서로 다른 사용자라도 같은 이름 사용 불가

  <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.5.png">

- ##### 2단계 디렉터리

  > 사용자에게 개별적인 디렉터리 만들어줌

  - UFD : 자신만의 사용자 파일 디렉터리
  - MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리

  <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.6.png">

- ##### 트리 구조 디렉터리

  > 2단계 구조 확장된 다단계 트리 구조

  한 비트를 활용하여, 일반 파일(0)인지 디렉터리 파일(1) 구분

  <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.7.png">

- 그래프 구조 디렉터리

  > 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시

  링크가 있으면 우회하여 순환을 피할 수 있음

  <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.9.png">













##### [참고 자료]

- [링크]( https://noep.github.io/2016/02/23/10th-filesystem/ )